<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>ConfigStation for WCF – prototype for minimal configuration based WCF services</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">

    </head>
    <body>

        <div class="site">
          <div class="header">
            <h1 class="title"><a href="/">Your New Jekyll Site</a></h1>
            <a class="extra" href="/">home</a>
          </div>

          <h2>ConfigStation for WCF – prototype for minimal configuration based WCF services</h2>
<p class="meta">28 Jul 2009</p>

<div class="post">
<p>To start off, I would like to stress that I am not a WCF expert and if you go around my blog, you can notice me writing about lot of different things – WPF, DLR, Web Development and what not. So what I present is just something that I made recently as a part of a bigger project that I plan to release. Apparently, this is pretty good start for what I envision for avoiding Configuration Hell in WCF services.</p>  <p>The <a href="http://msdn.microsoft.com/en-us/netframework/bb499684.aspx">StockTrader sample from Microsoft comes with a great library – Configuration Service 2.04</a>. The library is pretty good and provides wonderful functionality but the major problem with that, for me, is its strong dependency on the SQL Server backend. In short, the configuration service maintains a service configuration repository which is used to provide centralized configuration repository, load balancing, fail-over in WCF based SOA applications. And I always wanted such a repository which would minimize my effort in developing distributed applications using WCF.</p>  <p>I believe, WCF should allow very simple way to develop services and should provide an easier means to configure them. One way away from configuration through App.Config is to code the configuration, but there seems to be a big lack of proper documentation and decent-real-world samples explaining code-based WCF configuration. Anyway, I would envision hosting a service to be as simple as :</p> <span class="c#" name="code">   <p>var serviceHost = new AutoConfiguredServiceHost&lt;ServiceImpl&gt;();</p> </span>  <p>With no or minimal configuration, the service host should be clever enough to determine what the configuration defaults are. Similarly, consuming the service should be as simple as :</p> <span class="c#" name="code">   <p>var client = new RemoteServiceProxy&lt;IService&gt;();</p> </span>  <p>The proxy should be created by accessing the repository to figure out implementation for IService and then use the configuration obtained to create the proxy.</p>  <p>With these goals in mind, the config station has been developed and here is what I have so far.</p>  <p><strong>Sample : Test Service which hosts the ConfigRepository as well as a sample WCF Service implementation. The host method is shown below.</strong></p>  <pre class="c#" name="code"> class Program<br />    {<br />        static void Main(string[] args)<br />        {<br />            using (var configHost = new ConfigStationHost())<br />            {<br />                var hostFacade = new ServiceHostFacade&lt;TestImpl&gt;();<br />                var host = hostFacade.Host;<br />                host.Open();<br />                Console.WriteLine(&quot;Test service launched.Enter to Stop&quot;);<br />                Console.ReadLine();<br />                //host.Close();<br />                host.Abort();<br />            }<br />        }<br />    }</pre><br /><br /><p>If you look at the using block, I am creating an instance of ConfigStationHost – which actually hosts the ConfigStation – a repository WCF service. At the moment, this service requires App.Config based configuration of the service – which can be easily removed and which would be my next enhancement to the project. In this example, I am actually hosting the ConfigStation within the same process as my actual WCF service, which is not required at all. You can host the ConfigStation in a totally separate program – all you have to do is create the instance of ConfigStationHost (see required configuration below) and dispose it when you are done.</p><br /><br /><p>The configuration for the Test Service is shown below.</p><br /><br /><pre class="xml" name="code"> <br />&lt;configuration&gt;<br />  <br />  &lt;appsettings&gt;<br />    &lt;add value=&quot;net.tcp&quot; key=&quot;ServiceScheme&quot; /&gt; &lt;!-- you can set this to http as well or even msmq ...--&gt;<br />    &lt;add value=&quot;9989&quot; key=&quot;ServicePort&quot; /&gt;<br />  &lt;/appsettings&gt;<br />  <br />  &lt;system.servicemodel&gt;<br />    &lt;services&gt;<br />      &lt;service name=&quot;ConfigStation.Repository&quot;&gt;<br />        &lt;endpoint contract=&quot;ConfigStation.ServiceContracts.IRepository&quot; binding=&quot;wsHttpBinding&quot; address=&quot;http://localhost:8731/ConfigStation/Repository&quot; /&gt;<br />      &lt;/service&gt;<br />    &lt;/services&gt;<br />    <br />    &lt;!-- This demo acts as a client to ConfigStation, so it is all good--&gt;<br />    &lt;client&gt;<br />      &lt;endpoint name=&quot;ConfigStation&quot; contract=&quot;ConfigStation.ServiceContracts.IRepository&quot; binding=&quot;wsHttpBinding&quot; address=&quot;http://localhost:8731/ConfigStation/Repository&quot;&gt;<br />      &lt;/endpoint&gt;<br />    &lt;/client&gt;<br />    <br />  &lt;/system.servicemodel&gt;<br />&lt;/configuration&gt;</pre><br /><br /><p>In the shown configuration, the &lt;service&gt; element configuration is used to host the ConfigStation repository in the current process. The &lt;client&gt; configuration is&#160; the WCF client configuration which is used to access the ConfigStation service hosted. The TestService makes interacts with the ConfigStation using WCF and the ConfigStation is treated as a WCF service hosted somewhere remote. So, if we were to host the configstation separately the only configuration required would be that of the &lt;service&gt; defined. The TestService would then have the AppSettings and the &lt;client&gt; configuration – which is pretty easy to set and even easier for me to remove.</p><br /><br /><p>Now, the ServiceScheme dictates what communication protocol (BINDING, in terms of WCF) would be used when exposing the service and what binding would be used by the clients consuming this service. The ServicePort tells what port the service should be hosted on. Note that WCF allows hosting multiple services on the same port as long as their address is different (Except for MSMQ, i think).</p><br /><br /><p><strong>The test client to consume the TestService is a different program, whose configuration is shown below. The program contains a WCF client to the TestImpl service whose details are obtained from the ConfigStation. Thus, the client process requires configuration which points to the ConfigStation.</strong></p><br /><br /><pre class="xml" name="code">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;<br />&lt;configuration&gt;<br />  &lt;system.serviceModel&gt;<br />  &lt;client&gt;<br />    &lt;endpoint address=&quot;http://localhost:8731/ConfigStation/Repository&quot; name=&quot;ConfigStation&quot;<br />              binding=&quot;wsHttpBinding&quot;<br />              contract=&quot;ConfigStation.ServiceContracts.IRepository&quot;&gt;<br />    &lt;/endpoint&gt;<br />  &lt;/client&gt;<br />  &lt;/system.serviceModel&gt;<br />&lt;/configuration&gt;</pre><br /><br /><p>As you can see, the above is the only configuration required – which would be eliminated once I enhance the ConfigStation. The actual code to access the client is shown below.</p><br /><br /><pre class="xml" name="code">namespace Test.Client<br />{<br />    class Program<br />    {<br />        static void Main(string[] args)<br />        {<br />            var cf = new ClientProxyFacade&lt;ITest&gt;();<br />            ITest test = cf.Interface;<br />            var td = test.SayHello();<br />            Console.WriteLine(&quot;Remote Server returned : &quot; + td.Message);<br />        }<br />    }<br />}</pre><br /><br /><p>You just create the ClientProxyFacade Of ITest, the service contract used by TestImpl. Then the interface is obtained via the “Interface” property. Then you can execute any method exposed by the Service Contract.</p><br /><br /><p><a href="http://configstation.codeplex.com/">The library is available on codeplex</a> – making this my first public release of open source software, of any kind. In the process, I would like to stress that the library uses the amazing <a href="http://www.idesign.net/idesign/DesktopDefault.aspx?tabindex=5&amp;tabid=11">ServiceModelEx library from Juval Lowy, IDesign.</a> I actually tried to contact Juval whether or not to use his library but guess he is too busy so I took the liberty to publish the project having seen a WCF project on google code doing the same. In case I breach any license, please go easy on me and let me know so that I can fix my mistake. </p><br /><br /><p>I appreciate any positive feedback and any expert advice on the library. I am glad to learn and fix any changes requested. :) Hope this helps a few of us devs who like to play with some convention based WCF programming. I would be talking more details on the actual implementation, on how the library performs auto-generation of the service configuration and how bad the current repository implementation is, in my next post.</p>  
</div>


          <div class="footer">
            <div class="contact">
              <p>
                Your Name<br />
                What You Are<br />
                you@example.com
              </p>
            </div>
            <div class="contact">
              <p>
                <a href="https://github.com/yourusername">github.com/yourusername</a><br />
                <a href="https://twitter.com/yourusername">twitter.com/yourusername</a><br />
              </p>
            </div>
          </div>
        </div>

    </body>
</html>
