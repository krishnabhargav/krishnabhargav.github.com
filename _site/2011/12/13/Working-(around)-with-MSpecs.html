<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Working (around) with MSpecs</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">

    </head>
    <body>

        <div class="site">
          <div class="header">
            <h1 class="title"><a href="/">Your New Jekyll Site</a></h1>
            <a class="extra" href="/">home</a>
          </div>

          <h2>Working (around) with MSpecs</h2>
<p class="meta">13 Dec 2011</p>

<div class="post">
I just started playing with <a href="https://github.com/machine/machine.specifications" target="_blank">Machine.Specifications</a> (MSpecs). Overall I am very satisfied with the project but I did ran across some issues - dont get me wrong, it works great but it was more like limitations because I was lame and using Express edition.<br />My specs are simple - I am trying to create a Dependency Injection Container that does absolutely very little, not as powerful as Unity or any other containers. I dont plan to use it anywhere - just am trying to create one for fun. So the specifications are simple (for now).<br /><pre class="xml" name="code"> <br />Mapping Interface to Type, MappingInterfaceToType<br />  » should allow creating instance of type registered<br />  <br />  In case of multiple constructors, pick the one with injection attribute, MultipleConstructorScenario<br />  » should create instance whose Value property is 20<br />  <br />  Container should support singleton instances, SingletonScenario<br />  » should return the same instance for every invocation<br />  <br />  Inner container should be supported, SupportForInnerContainer<br />  » should return registration from parent and itself</pre><br /><br />Simple right? Those are the output for my specifications. It it still under works but the output itself explains a lot - thats the power of the MSpecs. Business Analysts write requirements, gives specifications - This can be changed - they give us the requirements and we "program" the specifications. I know it appears to be some rewired Unit Testing, but if unit tests can give me a bunch of specifications and tell me what failed, I would be more than happy to use that. <br /><br /><br />Now lets write a specification from scratch. Look at the following simple C# code. <br /><pre class="csharp" name="code"> public class Singleton { }<br />        public class Transient<br />        {<br />            public Singleton SingletonInstance { get; private set; }<br />            public Transient(Singleton ins)<br />            {<br />                SingletonInstance = ins;<br />            }<br />        }</pre><br />I would like to register the Singleton class as - singleton and the transient class as - transient. So my specification is, <strong>instances of transient whose dependency is a singleton should get the same instance. </strong>So that becomes my "Subject" <br /><br /><br /><pre class="csharp" name="code">[Subject("instances of transient whose dependency is a singleton should get the same instance.")]<br />public class InjectionOfSingletonForTransientResolution<br />{<br />}</pre><br />Now to verify that specification, I need to <strong>"establish a context"</strong> which is that I need my container to be ready for use.<br /><pre class="csharp" name="code"> Establish context = () =&gt;<br /> {<br />            _builder = new TypeBuilder();<br /> };</pre><br />Now that context is established, I will just write my specification. I create two instances and both my instances should have the same instance of Singleton. <br /><pre class="csharp" name="code"><br />It Should_Use_The_Same_Instance_when_creating_dependent_Components = () =><br />{<br />            var instance1 = _builder.Resolve<transient>();<br />            var instance2 = _builder.Resolve<transient>();<br />            instance1.ShouldNotEqual(instance2);<br />            instance1.SingletonInstance.ShouldNotBeNull();<br />            instance2.SingletonInstance.ShouldNotBeNull();<br />            instance1.SingletonInstance.ShouldEqual(instance2.SingletonInstance);<br />};<br /></pre><br />But you know this would not happen just like that. I have my context and I know what it should do. I need to tell it why it should do that - that specification would pass <strong>"because I am registering dependency as singleton and instance as transient".</strong> So I add my reasons on why (or when) the specification would pass.<br /><pre class="csharp" name="code"><br />Because I_Am_Making_A_Dependency_Registration_As_Singleton_And_TestSubject_As_Transient = () =><br />{<br />            _builder.Register<singleton>(new Singleton());<br />            _builder.Register<transient>();<br />};<br /></pre><br />The whole specification would look like shown below. <br /><pre class="csharp" name="code">[Subject("instances of transient whose dependency is a singleton should get the same instance.")]<br />    public class InjectionOfSingletonForTransientResolution<br />    {<br />        static ITypeBuilder _builder;<br /><br />        public class Singleton { }<br />        public class Transient<br />        {<br />            public Singleton SingletonInstance { get; private set; }<br />            public Transient(Singleton ins)<br />            {<br />                SingletonInstance = ins;<br />            }<br />        }<br /><br />        Establish context = () =><br />        {<br />            _builder = new TypeBuilder();<br />        };<br /><br />        Because I_Am_Making_A_Dependency_Registration_As_Singleton_And_TestSubject_As_Transient = <br />        () =><br />        {<br />            _builder.Register<singleton>(new Singleton());<br />            _builder.Register<transient>();<br />        };<br /><br />        It Should_Use_The_Same_Instance_when_creating_dependent_Components = () =><br />        {<br />            var instance1 = _builder.Resolve<transient>();<br />            var instance2 = _builder.Resolve<transient>();<br />            instance1.ShouldNotEqual(instance2);<br />            instance1.SingletonInstance.ShouldNotBeNull();<br />            instance2.SingletonInstance.ShouldNotBeNull();<br />            instance1.SingletonInstance.ShouldEqual(instance2.SingletonInstance);<br />        };<br />    }<br /></pre><br />When I first run this my specification failed because my container does not handle that yet. <br /><pre class="xml" name="code"> instances of transient whose dependency is a singleton should get the same instance., InjectionOfSingletonForTransientResolution<br />  » Should Use The Same Instance when creating dependent Components (FAIL)<br />  Machine.Specifications.SpecificationException: Should be [not null] but is [null]<br />     at Machine.Specifications.ShouldExtensionMethods.ShouldNotBeNull(Object anObject) in d:\BuildAgent-03\work\38fe83de684fd902\Source\Machine.Specifications\ExtensionMethods.cs:line 181<br />     at Analytics.Specifications.Container.InjectionOfSingletonForTransientResolution.&lt;.ctor&gt;b__2() in C:\Users\bhargav\documents\visual studio 2010\Projects\Analytics\Analytics.Specifications\Container\TypeBuilderSpecs.cs:line 159<br />     at Machine.Specifications.Model.Specification.InvokeSpecificationField() in d:\BuildAgent-03\work\38fe83de684fd902\Source\Machine.Specifications\Model\Specification.cs:line 75<br />     at Machine.Specifications.Model.Specification.Verify() in d:\BuildAgent-03\work\38fe83de684fd902\Source\Machine.Specifications\Model\Specification.cs:line 53</pre><br />I fix my container and now I see my specification pass.<br /><br />One thing to remember is what ever you are working off - your context - it should be static - otherwise the compilation would fail. when looking at others examples, I had a similar question - so here I am telling you upfront.<br /><br /><h3>Running specifications without leaving Visual Studio - No test runners are required.</h3><br />All my specifications are in a separate class library. I would like to run the specifications without leaving Visual Studio (btw, I am using Express). I remember once upon a time I could make a class library as a startup project and somehow linked NUnit gui runner with the project. I could not get it done with VC# 2010 Express anymore. May be I am missing something. Anyway the solution was to add the following Post-Build event<br /><br /><a href="http://lh3.ggpht.com/_Oy9HuksgrdU/TTJ6ruuy-ZI/AAAAAAAABbY/4OD3cJB2Sns/s1600-h/image%5B3%5D.png"><img alt="image" border="0" height="277" src="http://lh5.ggpht.com/_Oy9HuksgrdU/TTJ6sZXdyjI/AAAAAAAABbc/PhFKCTD1BB0/image_thumb%5B1%5D.png?imgmax=800" style="background-image: none; border-bottom-width: 0px; border-left-width: 0px; border-right-width: 0px; border-top-width: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="644" /></a><br /><br />Once my specifications project it built successfully, it automatically generates a nice output. You can use all command line arguments that mspec supports, for now I only care if they pass or fail, hence the simple one.<br /><br /><h3>Debugging my specifications. It was painful</h3><br />I tried all different strategies like using System.Diagnostics.Debugger.Break() and what not. ConsoleRunner that comes with mspec (mspec.exe) was crashing complaining that it encountered an user defined breakpoint in the code - yeah that was my intention. Anyway to work around that, I create a console program and in the console application, I added reference to my specifications library and from the Git Hub source code for the mspec.exe (thanks to OSS) the following C# code helped me overcome my limitation of not being able to use R# or TestDriven.Net.<br /><pre class="csharp" name="code"> class ContainerSpecsRunner<br />    {<br />        static void Main(string[] args)<br />        {<br />            //Console.WriteLine(typeof(ITest).Assembly.Location);<br />            Program prog = new Program(new DefaultConsole());<br />            prog.Run(new[] { typeof(ITest).Assembly.Location });<br />        }<br />    }</pre><br />ITest is a type that was defined in my specifications assembly. That way I need not worry about any arguments or hardcode path of my assembly. By the way, at work you might be killed for doing this, I am just doing it at my personal projects.<br /><br /><h3>Some samples? </h3><br />Ok the biggest problem I had was that I could not find some real world examples, the GIT HUB structure of the project was confusing as hell. I was hoping to find some examples, but I could not. As much as I like the project, I hate to see so little or almost non-existent guidance for new users. So here are some of my specifications. These are written by me - I am just learning the style of specs so forgive me if they are not what you wanted them to be. I am just trying to help. <br /><pre class="csharp" name="code">public interface ITest{<br />    }<br /><br />    public class Test: ITest{<br />        [Injector]<br />        public Test()<br />        {<br /><br />        }<br />    }<br /><br />    [Subject("Mapping Interface to Type")]<br />    public class MappingInterfaceToType<br />    {<br />        static ITypeBuilder _builder;<br /><br />        Establish context = () =&gt;<br />        {<br />            _builder = new TypeBuilder();<br />        };<br /><br />        Because of = () =&gt;<br />        {<br />            _builder.Register<itest ,="" test="">();<br />        };<br /><br />        It should_allow_creating_instance_of_type_registered = () =&gt;<br />        {<br />            var resolvedObject = _builder.Resolve<itest>();<br />            resolvedObject.ShouldNotBeNull();<br />            typeof(Test).ShouldEqual(resolvedObject.GetType()); <br />        };<br />    }<br /><br />    [Subject("In case of multiple constructors, pick the one with injection attribute")]<br />    public class MultipleConstructorScenario<br />    {<br />        public class Test2 : ITest<br />        {<br />            public int Value { get; private set; }<br />            public Test2(ITest demo)<br />            {<br />                Value = 10;<br />            }<br /><br />            [Injector]<br />            public Test2()<br />            {<br />                Value = 20;<br />            }<br />        }<br /><br />        static ITypeBuilder _builder;<br />        Establish context = () => {<br />            _builder = new TypeBuilder();<br />        };<br /><br />        Because of = () =><br />        {<br />            _builder.Register<ITest,Test2>();<br />        };<br /><br />        It should_create_instance_whose_Value_property_is_20 = ()=><br />{<br />            var instance = _builder.Resolve<ITest>();<br />            instance.ShouldBeOfType<Test2>();<br />            (instance as Test2).Value.ShouldEqual(20);<br />        };<br />    }<br /><br />    [Subject("Container should support singleton instances")]<br />    public class SingletonScenario<br />    {<br />        static ITypeBuilder _builder;<br /><br />        Establish context = () =><br />        {<br />            _builder = new TypeBuilder();<br />        };<br /><br />        Because instance_Is_Registered = () =><br />        {<br />            _builder.Register<ITest>(()=>new Test());<br />        };<br /><br />        It should_return_the_same_instance_for_every_invocation = () =><br />        {<br />            _builder.Resolve<ITest>().ShouldEqual(_builder.Resolve<ITest>());<br />        };<br />    }<br /><br />    [Subject("Inner container should be supported")]<br />    public class SupportForInnerContainer<br />    {<br />        static ITypeBuilder _builder;<br />        static ITypeBuilder _child;<br />        Establish context = () =><br />        {<br />            _builder = new TypeBuilder();<br />            _child = _builder.CreateChildBuilder();<br />        };<br /><br />        Because instance_is_registered_with_child_container = () =><br />        {<br />            _builder.Register<IEnumerable>(new int[] { 0, 1, 2 });<br />            _child.Register<ITest,Test2>();<br />        };<br /><br />        It should_return_registration_from_parent_and_itself = () =><br />        {<br />            var arr = (int[])_child.Resolve<IEnumerable>();<br />            arr.SequenceEqual(new[] { 0, 1, 2 }).ShouldBeTrue();<br />            _child.Resolve<ITest>().ShouldBeOfType<Test>();<br />        };<br />    }<br /></pre><br /><br /><h3>Would be nice if it can print my "Because" field names</h3><br />Just like the console runner prints my "It" fields, it would be nicer if my reasons are printed. I will see if i can do that myself to the project and may contribute a little.<br /><br /><br />I hope the examples are useful. By no means they are perfect but they can get you started. You can see in the example I detailed in the beginning, I had a whole bunch of Should statements = that is plain wrong. Each specification should define one thing - otherwise it would be a big mess. Please look at this great project and I really am in love with MSpec.
</div>


          <div class="footer">
            <div class="contact">
              <p>
                Your Name<br />
                What You Are<br />
                you@example.com
              </p>
            </div>
            <div class="contact">
              <p>
                <a href="https://github.com/yourusername">github.com/yourusername</a><br />
                <a href="https://twitter.com/yourusername">twitter.com/yourusername</a><br />
              </p>
            </div>
          </div>
        </div>

    </body>
</html>
