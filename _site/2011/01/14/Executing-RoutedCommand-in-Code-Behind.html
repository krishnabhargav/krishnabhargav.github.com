<!DOCTYPE html>
<html>
<head>   
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />

    <title>Vedhava Sodhi - Musings of a Software Engineer v2.0</title>
    <meta name="description" content="" />

    <meta name="HandheldFriendly" content="True" />
    <meta name="MobileOptimized" content="320" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="stylesheet" type="text/css" href="/assets/css/normalize.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/screen.css" />
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Noto+Serif:400,700,400italic|Open+Sans:700,400" />
    <!-- This is for syntax highlight -->
    <link rel="stylesheet" type="text/css" href="/assets/css/syntax.css">
    <!-- Customisation  -->
    <link rel="stylesheet" type="text/css" href="/assets/css/main.css" />

</head>
<body class="home-template">

    
    <main class="content" role="main">

    <article class="post">
        <header class="post-header">
            <a id="blog-logo" href="/">
                
                    <span class="blog-title">Vedhava Sodhi</span>
                 
            </a>
        </header>
        
        <span class="post-meta">
        	<time datetime="2011-01-14">14 Jan 2011</time>
        	
        		on
	        	
	        
       	</span>

        <h1 class="post-title">Executing RoutedCommand in Code-Behind</h1>

        <section class="post-content">
            <p>Recently I had this issue where we had a bunch of routed commands but those which were to be bound to an event instead of directly on a Button.Command. Anyway with all the event to command redirection (hint: use System.Windows.Interactivity EventTriggers and TriggerAction&lt;FrameworkElement&gt;), the requirement boiled down to executing a RoutedCommand in code behind.</p> <p>Consider the command had a base class which looks as shown below.</p><pre class="csharp" name="code">public abstract class CommandBase<br />    {<br />        public ICommand Command { get; private set; }<br />        public CommandBinding CommandBinding { get; private set; }<br />        public CommandBase()<br />        {<br />            Command = new RoutedCommand();<br />            CommandBinding = new CommandBinding(Command, HandlerExecute, HandlerCanExecute);<br />        }<br /><br />        private void HandlerExecute(object sender, ExecutedRoutedEventArgs args)<br />        {<br />            Execute(args.Parameter);<br />        }<br /><br />        private void HandlerCanExecute(object sender, CanExecuteRoutedEventArgs args)<br />        {<br />            args.CanExecute = CanExecute(args.Parameter);<br />        }<br /><br />        protected abstract void Execute(object parameter);<br /><br />        protected abstract bool CanExecute(object parameter);<br /><br />        public static void DoCommandBind(CommandBase command, FrameworkElement element)<br />        {<br />            element.CommandBindings.Add(command.CommandBinding);<br />        }<br />    }<br /></pre><br /><p> The base class simply provides everything that you need to make use of RoutedCommand. It wraps the command and its command binding whose execute and can execute handlers are redirected to the abstract methods. So the implementation would be as simple as the one shown below and you would have a full fledged RoutedCommand</p><br /><br /><pre name="code" class="csharp"><br />public class SampleCommand : CommandBase<br />    {<br />        protected override void Execute(object parameter)<br />        {<br />            MessageBox.Show(parameter.ToString());<br />        }<br /><br />        protected override bool CanExecute(object parameter)<br />        {<br />            return parameter != null;<br />        }<br />    }<br /></pre><br /><p>In the above command, I simply execute the command if there is a parameter sent and when executed display the parameter passed in a MessageBox. In order to use this command in XAML, the markup would be as simple as : </p><br /><pre name="code" class="xml"><br />&lt;Button Command="{Binding Sample.Command}" CommandParameter="This is from XAML" Content="From XAML" /&gt;<br /></pre><br /><p>But for the RoutedCommand to work, the CommandBinding associated with it should be added to one of the elements up in the Visual Tree. So one of the parents for the Button should have the CommandBinding for the command to be registered with them. This is performed using the CommandBase.DoCommandBind() method. This is required because - the RoutedCommand - even though it implements ICommand interface, the Execute() and CanExecute() methods simply trigger the events that result in the CommandBinding execute the handlers that were specified when the command binding was being created. Read on MSDN for a much better english explanation. If the command binding cannot be found on any of the ancestors, the command would never fire! This is important to understand when we later look at the C# way to execute a RoutedCommand. </p><br /><br /><p> For now, look at the code behind. It is simple and what happens in the constructor is self explanatory. </p><br /><br /><pre name="code" class="csharp"><br />        private CommandBase sample = new SampleCommand();<br />        <br />        public CommandBase Sample<br />        {<br />            get { return sample; }<br />        }<br /><br />        public CommandDemo()<br />        {<br />            InitializeComponent();<br />            this.DataContext = this;<br />	    //do a command binding on this UserControl itself.<br />            CommandBase.DoCommandBind(sample, this);<br />        }<br /></pre><br /><br /><h3>Gotcha 1 : RoutedCommand does not fire!</h3><br /><p>If this is the case, then make sure the CommandBinding for the RoutedCommand has been registered properly. You can do it in Code-Behind (like CommandBase.DoCommandBind() in my example) or in XAML (loads of examples online for that).</p><br /><br /><h3> How do I execute a RoutedCommand from code-behind? </h3><br /><p> Again, same rules apply. The command binding should be available to be found on the ancestors where the command will be fired. If that is the case, then you can do it in the following way.</p><br /><br /><pre name="code" class="csharp"><br />var rc = (sample.Command as RoutedCommand);<br />if (rc.CanExecute("This is command parameter", e.OriginalSource as Control))<br />   rc.Execute("This is command parameter", e.OriginalSource as Control);<br /></pre><br /><br /><P> Executing the ICommand.Execute(parameter) (eg: sample.Command.Execute("parameter")) would work, but if in any case it does not work, use the method above. </p><br /><h3>Gotcha 2 : RoutedCommand.CanExecute(parameter) does not fire when executing a RoutedCommand from code-behind!</h3><br /><p> Yes, ICommand.CanExecute() is just an interface method, its the job the command invoker (if done in code-behind, it is you who is the command invoker) to verify if the command can be executed using CanExecute(). </p><br /><br /><p> Well, thats all for now, I hope this helps some of us who were struggling with one place solution to execute RoutedCommands in code-behind. Hopefully, I will write  one more brief article on using System.Windows.Interactivity.Triggers to redirect an event to a command, the MVVM way of executing actions. </p>  
        </section>

        

        <footer class="post-footer">
        	<!-- If we want to display author's name and bio -->
            

            <section class="share">
                <h4>Share this post</h4>
                <a class="icon-twitter" href="http://twitter.com/share?text=Executing RoutedCommand in Code-Behind&amp;url=/2011/01/14/Executing-RoutedCommand-in-Code-Behind.html"
                    onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
                    <span class="hidden">Twitter</span>
                </a>
                <a class="icon-facebook" href="https://www.facebook.com/sharer/sharer.php?u=/2011/01/14/Executing-RoutedCommand-in-Code-Behind.html"
                    onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
                    <span class="hidden">Facebook</span>
                </a>
                <a class="icon-google-plus" href="https://plus.google.com/share?url=/2011/01/14/Executing-RoutedCommand-in-Code-Behind.html"
                   onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
                    <span class="hidden">Google+</span>
                </a>
            </section>
            
            
        	
        </footer>

    </article>

</main>


    <footer class="site-footer">
        <a class="subscribe icon-feed" href="/rss.xml"><span class="tooltip">Subscribe!</span></a>
        <div class="inner">
             <section class="copyright">All content copyright <a href="/">Vedhava Sodhi</a> &copy;  &bull; All rights reserved.</section>
             <section class="poweredby">Made with Jekyll using <a href="http://github.com/rosario/kasper">Kasper theme</a></section>
        </div>
    </footer>

    
    <script type="text/javascript" src="/assets/js/jquery-1.10.2.min.js"></script>
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="/assets/js/index.js"></script>

    <!-- Google Analytics Tracking code -->
    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-XXXXXXXX-X']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();

    </script>   
</body>
</html>
