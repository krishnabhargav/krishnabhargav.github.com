<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>WPF Datagrid – Load and Performance</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">

    </head>
    <body>

        <div class="site">
          <div class="header">
            <h1 class="title"><a href="/">Your New Jekyll Site</a></h1>
            <a class="extra" href="/">home</a>
          </div>

          <h2>WPF Datagrid – Load and Performance</h2>
<p class="meta">16 Jul 2010</p>

<div class="post">
<p>This post is not about performance numbers of WPF Datagrid but simply about what you should be aware of in order to make it perform well. I was not motivated enough to use profiler to show realistic numbers but instead used the Stopwatch class wherever applicable. This post does not go into techniques to handle large amounts of data such as Paging or how to implement paging, but focuses on how to make the datagrid work with large data.</p> <p>Here is the C# class that generates the data I want to load the Datagrid with.</p><pre class="csharp" name="code">public class DataItem<br />    {<br />        public long Id { get; set; }<br />        public string FirstName { get; set; }<br />        public string LastName { get; set; }<br />        public long Age { get; set; }<br />        public string City { get; set; }<br />        public string Designation { get; set; }<br />        public string Department { get; set; }<br />    }<br /><br />    public static class DataGenerator<br />    {<br />        private static int _next = 1;<br />        public static IEnumerable<dataitem> GetData(int count)<br />        {<br />            for (var i = 0; i &lt; count; i++)<br />            {<br />                string nextRandomString = NextRandomString(30);<br />                yield return new DataItem<br />                                 {<br />                                     Age = rand.Next(100),<br />                                     City = nextRandomString,<br />                                     Department = nextRandomString,<br />                                     Designation = nextRandomString,<br />                                     FirstName = nextRandomString,<br />                                     LastName = nextRandomString,<br />                                     Id = _next++<br />                                 };<br />            }<br />        }<br /><br />        private static readonly Random rand = new Random();<br /><br />        private static string NextRandomString(int size)<br />        {<br />            var bytes = new byte[size];<br />            rand.NextBytes(bytes);<br />            return Encoding.UTF8.GetString(bytes);<br />        }<br />    }<br /></pre><br /><p>My ViewModel has been defined as shown below.</p><pre class="csharp" name="code"> public class MainWindowViewModel : INotifyPropertyChanged<br />    {<br />        private void Notify(string propName)<br />        {<br />            if (PropertyChanged != null)<br />                PropertyChanged(this, new PropertyChangedEventArgs(propName));<br />        }<br />        public event PropertyChangedEventHandler PropertyChanged;<br /><br />        private Dispatcher _current;<br />        public MainWindowViewModel()<br />        {<br />            _current = Dispatcher.CurrentDispatcher;<br />            DataSize = 50;<br />            EnableGrid = true;<br />            _data = new ObservableCollection<dataitem>();<br />        }<br /><br />        private int _dataSize;<br />        public int DataSize<br />        {<br />            get { return _dataSize; }<br />            set<br />            {<br />                LoadData(value - _dataSize);<br />                _dataSize = value;<br />                Notify("DataSize");<br />            }<br />        }<br /><br />        private ObservableCollection<dataitem> _data;<br />        public ObservableCollection<dataitem> Data<br />        {<br />            get { return _data; }<br />            set<br />            {<br />                _data = value;<br />                Notify("Data");<br />            }<br />        }<br /><br />        private bool _enableGrid;<br />        public bool EnableGrid<br />        {<br />            get { return _enableGrid; }<br />            set { _enableGrid = value; Notify("EnableGrid"); }<br />        }<br /><br />        private void LoadData(int more)<br />        {<br />            Action act = () =&gt;<br />                             {<br />                                 EnableGrid = false;<br />                                 if (more &gt; 0)<br />                                 {<br />                                     foreach (var item in DataGenerator.GetData(more))<br />                                         _data.Add(item);<br />                                 }<br />                                 else<br />                                 {<br />                                     int itemsToRemove = -1 * more;<br />                                     for (var i = 0; i &lt; itemsToRemove; i++)<br />                                         _data.RemoveAt(_data.Count - i - 1);<br />                                 }<br />                                 EnableGrid = true;<br />                             };<br />            //act.BeginInvoke(null, null);<br />            _current.BeginInvoke(act, DispatcherPriority.ApplicationIdle);<br />        }<br />    }<br /></pre><br /><p>As you can see, as the DataSize is changed, the data would be loaded. Currently I use a slider to change the load size. This is all pretty easy and fun stuff starts in the XAML.</p><br /><p>In order to apply this "Data" to my WPF datagrid, I apply this viewmodel instance to the DataContext of my class. See below for the code-behind that I have for my window</p><pre class="csharp" name="code"> public partial class MainWindow : Window<br />    {<br />        private MainWindowViewModel vm;<br /><br />        public MainWindow()<br />        {<br />            InitializeComponent();<br />            vm = new MainWindowViewModel();<br />            this.Loaded += (s, e) =&gt; DataContext = vm;<br />        }<br />    }<br /></pre><br /><p>Lets start with the following XAML.</p><br /><p></p><pre class="xml" name="code">&lt;stackpanel&gt;<br />	&lt;slider maximum="100" minimum="50" value="{Binding DataSize}" /&gt;<br />        &lt;label grid.row="1" content="{Binding DataSize}"&gt;<br />        &lt;datagrid grid.row="2" isenabled="{Binding EnableGrid}" itemssource="{Binding Data}"&gt;<br />	&lt;/datagrid&gt;<br />&lt;/stackpanel&gt;<br /></pre><br /><p>Now build the application and run. The result appear as shown below. </p><br /><p><a href="http://lh4.ggpht.com/_Oy9HuksgrdU/TEDXbtApboI/AAAAAAAABZc/3rdhYAAloCQ/s1600-h/image%5B3%5D.png"><img style="border-right-width: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px" title="image" border="0" alt="image" src="http://lh5.ggpht.com/_Oy9HuksgrdU/TEDXdbsXOVI/AAAAAAAABZg/6v5-_uHi5bU/image_thumb%5B1%5D.png?imgmax=800" width="644" height="342"></a></p><br /><p>As you can see above, I loaded 100 items yet <strong>I do not see the scrollbar.</strong> Lets change the slider’s Maximum property from 100 to 1000 and rerun the application. Dragging the slider to 1000 at once. So even for the 1000 items, the grid does not respond that well. </p><br /><p><a href="http://lh4.ggpht.com/_Oy9HuksgrdU/TEDXese1pQI/AAAAAAAABZk/Lf5WvtHpv-Y/s1600-h/image%5B7%5D.png"><img style="border-right-width: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px" title="image" border="0" alt="image" src="http://lh5.ggpht.com/_Oy9HuksgrdU/TEDXgOGsWcI/AAAAAAAABZo/B66G-Pnfbj8/image_thumb%5B3%5D.png?imgmax=800" width="463" height="300"></a> </p><br /><p>Let us look at the memory usage.</p><br /><p><a href="http://lh5.ggpht.com/_Oy9HuksgrdU/TEDXg-J5y0I/AAAAAAAABZs/qussD_l9bj4/s1600-h/image%5B13%5D.png"><img style="border-right-width: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px" title="image" border="0" alt="image" src="http://lh5.ggpht.com/_Oy9HuksgrdU/TEDXiOXsUvI/AAAAAAAABZw/iU1PwM3QkSg/image_thumb%5B7%5D.png?imgmax=800" width="433" height="38"></a> </p><br /><p>This is pretty heavy for an application with just 1000 items of data loaded. So what is using all this memory? You can hook up a Memory Profiler or use Windbg to look at the memory content but since I already know what is causing this issue, I am not going through that. </p><br /><p>This issue is that the DataGrid has been placed inside a StackPanel. When vertically stacked, the StackPanel basically gives its children all the space that they ask for. This makes the DataGrid create 1000 rows (all the UI elements needed for each column of each row !!) and render it. The virtualization of the DataGrid did not come into play here.</p><br /><p>So let us make a simple change and put the DataGrid inside a grid. The XAML for which is shown below.</p><pre class="xml" name="code">&lt;Grid&gt;<br />        &lt;Grid.RowDefinitions&gt;<br />            &lt;RowDefinition Height="30"/&gt;<br />            &lt;RowDefinition Height="30"/&gt;<br />            &lt;RowDefinition Height="*"/&gt;<br />        &lt;/Grid.RowDefinitions&gt;<br />        &lt;Slider Value="{Binding DataSize}" Minimum="50" Maximum="1000"/&gt;<br />        &lt;Label Content="{Binding DataSize}" Grid.Row="1"/&gt;<br />        &lt;DataGrid ItemsSource="{Binding Data}" Grid.Row="2" IsEnabled="{Binding EnableGrid}"&gt;           <br />        &lt;/DataGrid&gt;<br />    &lt;/Grid&gt;<br /></pre><br /><p>When I run the application, you would notice that as I load 1000 items, the performance of the same application (no code changes, except that XAML one I just talked about) is a lot better than what it was. Moreover I see nice scrollbars.</p><br /><p></p><a href="http://lh6.ggpht.com/_Oy9HuksgrdU/TEDXklUvTrI/AAAAAAAABZ0/QRDfmfugJvc/s1600-h/image%5B19%5D.png"><img style="border-right-width: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px" title="image" border="0" alt="image" src="http://lh4.ggpht.com/_Oy9HuksgrdU/TEDXmBiLhWI/AAAAAAAABZ4/inpHNDHNOIY/image_thumb%5B11%5D.png?imgmax=800" width="644" height="342"></a> <br /><p>Let us look at the memory usage.</p><br /><p><a href="http://lh4.ggpht.com/_Oy9HuksgrdU/TEDXmkYFIJI/AAAAAAAABZ8/2Eip9xZ103Q/s1600-h/image%5B23%5D.png"><img style="border-right-width: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px" title="image" border="0" alt="image" src="http://lh3.ggpht.com/_Oy9HuksgrdU/TEDXn2IrfBI/AAAAAAAABaA/PxbE3KnIMJc/image_thumb%5B13%5D.png?imgmax=800" width="644" height="29"></a> </p><br /><p>Wow! 10 folds difference. This until now appears to be a re-talk about my <a href="http://krishnabhargav.blogspot.com/2008/10/wpf-performance-ui-virtualization.html">previous post on WPF Virtualization</a>. The same rules applies to DataGrid as well. Read this post if you are intertested.</p><br /><p>So what else am I talking here. </p><br /><ul><br /><li>If you notice the ViewModel code, you should be seeing that I disable the grid as I load data and enable it back once I am done. I have not really tested to see if this technique helps, but I did use this technique in HTML pages where loads of items in a listbox were all to be selected and this technique was very useful. <br /><li>In all the screenshots I showed, the grid is sorted. So as the data changes, the grid has to keep sorting the data and show based on what you chose to sort. This, I believe, is a big overhead. Consider removing sort of the datagrid before you change the data if it is a viable option and does not impact the end user. Have not tested this, but the same should apply to the groupings as well (which most of the time cannot be simply removed).</li></ul><br /><p>With a simple point of loading the DataGrid into any other panel like Grid, instead of a StackPanel you get to see a lot of difference. The WPF datagrid performs just fine, as long as you keep the viewable region of the grid small. </p><br /><p>Shown below is my grid with almost 1 Million data items loaded. The footprint is pretty small compared to the amount of data loaded. This means – either WPF Controls are memory intensive or WPF UI Virtualization is a boon.</p><br /><h3>Impact of sorting on the DataGrid</h3><br /><ul><br /><li>With no sorting applied on the datagrid, it took almost 20 seconds to load 1 Million items into my collection. <br /><li>With sorting enabled, loading half those items iteself took over 2 minutes and the complete items took over 5 minutes and I killed the application because it was a pain. This matters because the application keeps the CPU busy with all the sort that has to keep happening as your data changes. So for every item added, the sort might be triggered, since I am placing it directly into an observable collection. <br /><li><strong>Instead consider sorting on the backend and not using the datagrid.</strong></li></ul><br /><p><a href="http://lh6.ggpht.com/_Oy9HuksgrdU/TEDXpTKw1aI/AAAAAAAABaE/MJT3rJfALlk/s1600-h/image%5B31%5D.png"><img style="border-right-width: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px" title="image" border="0" alt="image" src="http://lh3.ggpht.com/_Oy9HuksgrdU/TEDXrgUUjsI/AAAAAAAABaI/yhRUGjP4-Cc/image_thumb%5B19%5D.png?imgmax=800" width="644" height="342"></a> </p><br /><p><em>I can still scroll the application if the virtualization was properly utilized, inspite of the grid binding to 1 million items<strong>.</strong></em></p><br /><h3>USING BeginInit() and EndInit() on the datagrid.</h3><br /><p>I changed the ViewModel’s LoadData() such that it calls BeginInit() as it starts loading the data and EndInit() when it done loading the data. This has helped quite a lot. Loading 1 Million items (without any sort applied on the grid) only took around 8 seconds (compared to the 18 seconds it took earlier). <strong>Unfortunately I did not spend enough time to use a profiler to show real numbers.</strong></p><br /><p>The changed code-behind for the Window is as shown.</p><pre class="csharp" name="code">public partial class MainWindow : Window<br />    {<br />        private MainWindowViewModel vm;<br /><br />        public MainWindow()<br />        {<br />            InitializeComponent();<br />            vm = new MainWindowViewModel();<br />            this.Loaded += (s, e) =&gt; DataContext = vm;<br />            vm.DataChangeStarted += () =&gt; dg.BeginInit();<br />            vm.DataChangeCompleted += () =&gt; dg.EndInit();<br />        }<br />    }<br /></pre><br /><p>I also had to include the DataChangeStarted and DataChangeCompleted actions to the Viewmodel class. The changed portion of the ViewModel class is shown below.</p><pre class="csharp" name="code">	public event Action DataChangeStarted ;<br />        public event Action DataChangeCompleted;<br /><br />        private void LoadData(int more)<br />        {<br />            Action act = () =&gt;<br />                             {<br />				 //Before the data starts change, call the method.<br />                                 if (DataChangeStarted != null) DataChangeStarted();<br />                                 var sw = Stopwatch.StartNew();<br />                                 EnableGrid = false;<br />                                 if (more &gt; 0)<br />                                 {<br />                                     foreach (var item in DataGenerator.GetData(more))<br />                                         _data.Add(item);<br />                                 }<br />                                 else<br />                                 {<br />                                     int itemsToRemove = -1 * more;<br />                                     for (var i = 0; i &lt; itemsToRemove; i++)<br />                                         _data.RemoveAt(_data.Count - i - 1);<br />                                 }<br />                                 EnableGrid = true;<br />                                 sw.Stop();<br />                                 Debug.WriteLine(sw.ElapsedMilliseconds);<br />                                 if (DataChangeCompleted != null) DataChangeCompleted();<br />                             };<br />            //act.BeginInvoke(null, null);<br />            _current.BeginInvoke(act, DispatcherPriority.ApplicationIdle);<br />        }<br /></pre><br /><p>You can try this out and notice the performance difference yourself. </p><br /><p>If the sorting is applied on the datagrid, the performance still hurts in spite of using the above mentioned trick. The overhead of sorting out weighs the performance gain we get calling the BeginInit and EndInit. May be having 1 million records is not realistic enough. </p>  
</div>


          <div class="footer">
            <div class="contact">
              <p>
                Your Name<br />
                What You Are<br />
                you@example.com
              </p>
            </div>
            <div class="contact">
              <p>
                <a href="https://github.com/yourusername">github.com/yourusername</a><br />
                <a href="https://twitter.com/yourusername">twitter.com/yourusername</a><br />
              </p>
            </div>
          </div>
        </div>

    </body>
</html>
