---           
layout: post
title: Asynchronous Programming - Delegates : Always a problem for 90% of .NET developers
date: 2006-02-16 19:55:45 UTC
updated: 2006-02-16 19:55:45 UTC
comments: false
categories: 
---

<div style="text-align: justify;">Most of us when working with GUI applications has definitely encountered certain problems with updated refresh of view. I mean to say that if you perform a task which takes atleast 10 seconds odd to finish, and then you try to switch between windows and attempt to get back to the main application window, you can notice that the application has freezed. You have numerous options to overcome this. the simplest one is write a void method/sub procedure and create a thread that executes that sub procedure. Inside the sub procedure, you can call the Refresh() or Update() method of the form you wish to refresh the view. Well this topic is not about how to use threads to make Windows applicaitons free of freezing effects, but is about asynchronous programming.<br /><br />Asynchronous method call is where we call the method and proceed to execute the next line after the call. We do not wait for the method to return. So how will you know when your method has finished execution? what if you want to return some information or a value once the method has been computed? As an answer to all these questions, there is the CALL BACK function. The call back function is that function that is executed when the method that has been invoked asynchronously has returned(completed execution) The call back function is passed as a delegate and so is the function that is being called. So learning how delegates work is the first step for one who wish to use asynchronous calls to functions. Almost all tasks which takes considerably good amount of time to execute have asynchronous versions, already provided. For example on a stream you have a BeginRead() method. All the methods that are asynchronous starts with "Begin" and has a corresponding "End" method which is actually a call back method.<br /><br />First of all. Let us look at working with delegates in simple terms. I am no expert and this is no documentation. So spare me if you dont understand and go join some coaching classes.<br /><span style="font-weight: bold;"><br />Basic Signature<br /></span>public delegate [returntype] [function-name]<returntype> <functioname>([parameters]<arguments>)  //C# version<br />public delegate <functioname></functioname></arguments></functioname></returntype> [function-name] ([parameters]) <returntype><functioname><arguments><functioname><arguments> as [returntype] <returntype> ' Vb.NET version<br /><span style="font-weight: bold;"></span><br /><span style="font-weight: bold;">For example<br /></span>public delegate int MathOperation(int a,int b);<br /><br />We have declared a delegate. delegates could be treated as objects, just that they can call only one method. Just follow the steps you shall understand.<br /><br />Step 1<br />1. Declare a delegate, usually outside the class as shown<br /><span style="font-style: italic;">         public delegate int MathOperation(int a,int b);<span style="font-style: italic;"><br /></span></span>2. You need to prepare a method same as the delegate signature. For example, for MathOperation a valid method would be as<br />      <span style="font-style: italic;">public int Addition(int a, int b)<br />       {<br />           return a+b;<br />       }<br /></span>3. You need to then create an instance of delegate passing the method name that it is supposed to call. Here,<br />   public static void Main(string[] args)<br />   {<br />       //create an instance of delegate<br />       MathOperation add=new MathOperation(Addition);<br />      Console.WriteLine(add(10,20));<br />   }<br />As you can see you invoke the method through delegate instance as shown <span style="font-weight: bold;">[</span> add(10,20) <span style="font-weight: bold;">] </span>It appears as if we have given a new name to the method instead of using the exisiting name. So what is the use of delegates when i could do the same without using delegates.<br /><br /><span style="font-weight: bold;">Usage??<br /></span>The need for delegates rises in the situtaion where there are two objects say <span style="font-weight: bold;">obj1 </span>and <span style="font-weight: bold;">obj2. </span>Obj1 has a reference to <span style="font-weight: bold;">obj2,</span> so <span style="font-weight: bold;">obj1</span> can invoke any method on the <span style="font-weight: bold;">obj2b, </span>but what if obj2 needs to invoke a method of obj1 whose reference it doesnt have. In that situation obj2 would provide a method to which obj1 can pass a delegate which holds the reference to the method of obj1 which obj2 needs to invoke. Inside the method of obj2, the delegate is registered with the obj2, so it is not the object reference that obj1 has but direct link to method of obj1. I hope you understand this. If you dont, then read again :))<br /><br /><span style="font-weight: bold;">[to be continued .....<br />[Next ... how to perform asynchronous method calls?]<br /></span><br /></returntype></arguments></functioname></arguments></functioname></returntype></div>