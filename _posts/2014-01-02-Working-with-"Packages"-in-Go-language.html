---           
layout: post
title: Working with "Packages" in Go language
date: 2014-01-02 13:40:54 UTC
updated: 2014-01-02 13:40:54 UTC
comments: false
categories: 
---

Packages in Golang<br /><br />The specification states that all source files for a package be stored in the same directory.<br />You can import a package as shown below.<br /><br /><pre name="code">import "fmt"<br /></pre><br />In this case, the Printf method may be accessed as fmt.Printf(). All other identifiers exported by the package is also accessible as fmt.XXXX().<br /><br />You can also do the following.<br /><br /><pre>import f "fmt"</pre>In this case, the qualifier is "f" instead of the default "fmt". So you access as "f.Printf()".<br /><br />One other way is the following. <br /><pre> import . "fmt" </pre>In this case, you dont need a qualifier for the exported identifiers from the fmt package. You may also use the blank identifier (underscore : _) as the qualifier name for cases where you wish the initialize the package but not necessarily import its exported identifiers. <br />Source files of a package have an init() function. See below for more details.<br />The previous example of a simple Web Server is now split into two files  <br /><pre class="c" name="code">//GoWebServer.go<br />package main<br /><br />import f "fmt"<br /><br />//init() is a special function that gets initialized.<br />func init(){<br /> f.Printf ("Package Initialized\n")<br />}<br /><br />func main() {<br /> f.Printf("Web Server will be started at port 8080\n")<br /> runWebServer()<br />}<br /></pre><pre class="c" name="code">//WebServerHelper.go<br /><br />package main<br /><br />import (<br /> . "fmt"<br /> "io"<br /> web "net/http"<br />)<br /><br />func init(){<br /> Printf("Initializing WebServerHelper.go \n")<br />}<br /><br />func runWebServer(){<br /> rootHandler := web.HandlerFunc(func(w web.ResponseWriter, r *web.Request) {<br />  io.WriteString(w, "Hi there, I love "+r.URL.Path)<br /> })<br /><br /> srv := web.Server{<br />  Handler: rootHandler,<br />  Addr:    ":8080",<br /> }<br /> srv.ListenAndServe()<br />}<br /></pre>Few things that I learnt when trying to make this work.<br />- You need to specify all the files required for your main program to build properly. So you may<br /><pre>go build</pre>Or you may run<br /><pre>go build *.go</pre>- You can also specify output to be generated as<br /><pre>go build -o output/gowebserver</pre>Or be more explicit<br /><pre>go build -o output/gowebserver *.go</pre>- Go complier does not like if a package is imported but not used. This is good. I cannot tell how annoying i find C# using statements that are just there but no one really uses them.<br /><div><br /></div><div>Notice that both the files have an init() function defined and when I build everything and run the program, the output is as follows:</div><pre>Package Initialized<br />Initializing WebServerHelper.go <br />Web Server will be started at port 8080<br /></pre><br />Such init() functions may be defined multiple times even in the same source file &amp; the execution order is unspecified/undefined. So we should not write our initialization logic based or the execution order. <br />And init() cannot be called by anyone else. Packages are initialized only once. So if you import packages P &amp; Q but Q also imports P, then P is initialized only once.<br /><br />Package initialization is comprised of variable initialization (package level variables are all assigned initial values) &amp; invocation of init() functions - performed one package at a time in a single go routine.<br /><br />See below for a basic program that indicates the above said sequence - variable initialization followed by init() method. <br /><pre class="c" name="code">package main<br /><br />import "fmt"<br /><br />//x := 2000<br />var x int = 2000<br /><br />func init(){<br /> var y int = x<br /> fmt.Printf("X value is %d\n",y)<br />}<br /><br />func main(){ }<br /></pre><br />x is a global variable (which by the way cannot use the shortcut notation that is commented) that is initialized to 2000 and that is what gets printed when the program is executed.<br /><h4>Local Packages in Go</h4>When you say <br /><pre>import "fmt" </pre>the package "fmt" is looked for in the standard Go tree. Then it is looked for in "$GOPATH/pkg" directory where $GOPATH is the environment variable set to some directory on your machine. Commands such as "go get" also looks for this directory. You can read more about it <a href="http://golang.org/pkg/go/build/">here (look for Go path)</a>.  So what about local packages - the one you do not want to put in GOPATH but leave it in the current directory for your application? To make this work, I renamed the package declaration (which originally was main) for the WebServerHelper.go as  <br /><pre>package ws</pre>Then I created a folder with the same name as the package &amp; placed the .go file in the folder. Then my import statements on the GoWebServer.go (the main file) has changed to  <br /><pre class="c" name="code">import (<br /> f "fmt"<br /> ws "./ws"<br />)<br /></pre>Notice the <b>"./ws"</b> declaration. So the import "XXX" statement says look for "XXX" file path. So without "./" it was looking in standard GO tree, then it looks at GOPATH. If there was a "./", it was just looking at the local directory. You may also give absolute paths. Also you don't need to build this directory specially. Just have your main file compile and you are good.  <br /><br />One other things that I had to change in the code to make the application work as before.<br />- In packages, if your function is to be exported, then it should start with upper case. In general, a field or a function or other identifiers within a package that starts with upper case letter are exported.  <br /><br />So if you are trying to make the previous code run (after the directory changes as described above), you will get the following<br /><br /><b>./GoWebServer.go:15: cannot refer to unexported name ws.runWebServer</b><br /><b>./GoWebServer.go:15: undefined: ws.runWebServer</b><br /><div><br /></div>So just change the name of the function to "RunWebServer" &amp; it becomes exported and ready to use.<br /><br />That's it for now!