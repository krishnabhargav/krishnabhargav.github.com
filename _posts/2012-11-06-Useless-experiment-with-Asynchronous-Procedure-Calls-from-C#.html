---           
layout: post
title: Useless experiment with Asynchronous Procedure Calls from C#
date: 2012-11-06 03:17:08 UTC
updated: 2012-11-06 03:17:08 UTC
comments: false
categories: 
---

<p>While Hurricane Sandy hit the East Coast and gave me a full week of vacation without electricity and internet, I gathered enough motivation to read through the very good book – concurrent programming on Windows by Joe Duffy. So here, I came across the Asynchronous Procedure Calls and what they mean. So this post is just a journal about me trying to do something clever (actually stupid) and sharing my madness with others.</p> <p>From what I learnt, an asynchronous procedure call (APC) is just a procedure that you can queue and request the OS that this procedure be performed on a particular thread. But that particular thread may be executing something right? So the question is when will the APC be executed? The answer for that is “it will be executed on the thread when it enters an ‘alertable wait’ state”. So what is an alertable wait?</p> <p>Consider the code below.</p><pre class="csharp" name="code">void IExecuteOnAThread(){<br />	lock(syncLock){<br />		while(conditionIsNotMet)<br />			Monitor.Wait(syncLock);<br />	}<br />}<br /></pre><br /><p>In the above snippet, the thread is actually waiting on the <strong>syncLock</strong>. When some other thread that makes the conditionIsNotMet as false and does a Pulse() on the syncLock, this current thread shall wake up and proceed with its execution. </p><br /><p>Now back to “alertable wait” –&gt; If a thread enters an alertable wait, then it can wake up properly (like in the case above) or can wake up for some other reason. This is how APC gets executed. When an APC gets queued on a thread, the OS will execute this APC the moment it finds that thread in an “alertable wait”.</p><br /><p>So while I think about this concept, it stuck to me (given that I am not that smart) to run a simple experiment. Usually, we queue work items into ThreadPool to get executed. Now the execution can happen in parallel so there is no order guarantee. In some cases, I would like to execute some asynchronous operations “in-order”; as queued; in the background (for whatever reason). In these cases, we typically use some kind of “executor” classes where a queue is almost always involved and some thread/threads wait for the work to be queued and execute them one by one – classic Producer/Consumer style. </p><br /><p>So what I wanted to try was to take advantage of APC and get away from not having to write any code to implement executors. </p><br /><ul><br /><li>I would simply create an “Executor” which has one thread which is always in an alertable wait state (Note that CLR takes care of making sure the Waits are resumed properly in case of any spurious wake-ups) <br /><li>The OS will take care of executing my operations one-by-one.</li></ul><br /><p>Note: For those who cannot wait till the end, do not do this – it is not worth it. I am just doing it because Sandy hit my head pretty hard.</p><pre class="csharp" name="code"> public class StupidExecutor<br />    {<br />        delegate void ApcProc(UIntPtr dwParam);<br /><br />        [DllImport("kernel32.dll")]<br />        static extern uint QueueUserAPC(ApcProc pfnApc, IntPtr hThread, UIntPtr dwData);<br /><br />        [DllImport("kernel32.dll")]<br />        static extern IntPtr GetCurrentThread();<br /><br />        private readonly AutoResetEvent _waiter = new AutoResetEvent(false);<br />        private IntPtr _threadId = IntPtr.Zero;<br /><br />        public StupidExecutor()<br />        {<br />            new Thread(WaitForApc).Start(null);<br />        }<br /><br />        public void Stop()<br />        {<br />            _waiter.WaitOne();<br />        }<br /><br />        private void WaitForApc(object none)<br />        {<br />            _threadId = GetCurrentThread();<br />            _waiter.WaitOne();<br />        }<br /><br />        public void QueueWork(Action action)<br />        {<br />            //while (Thread.VolatileRead(ref _threadId) == IntPtr.Zero)<br />            //    Thread.Sleep(0);<br />            var localAction = action;<br />            ApcProc apcProc = ((z) =&gt; localAction());<br />            QueueUserAPC(apcProc, _threadId, UIntPtr.Zero);<br />        }<br />    }</pre><br /><p>When the StupidExecutor gets created, a thread is launched which when started waits for a signal on a Auto Reset Event. This will make the thread wait because it is non-signalled and will remain so until Stop is executed on the executor. The executor has one method “QueueWork” which takes a delegate.</p><br /><p>So the usage of the stupid executor is as shown:</p><pre class="csharp" name="code">static void Main(string[] args)<br />        {<br />            var executor = new StupidExecutor();<br />            double[] avg = {0.0};<br />            int size = 1000;<br />            for (int j = 0; j &lt; size; j++)<br />            {<br />                var queued = DateTime.UtcNow;<br />                executor.QueueWork(() =&gt; avg[0] += (DateTime.UtcNow - queued).TotalMilliseconds);<br />            }<br />            Console.ReadLine();<br />            Console.WriteLine("Average Latency : "+avg[0]/size);<br />        }<br /></pre><br /><p>So the intention was to measure the latency (again not really the most efficient way). And I see an average latency of around 2 ms. So this must be a great way! Not really! First of all, for a <a href="http://www.bluebytesoftware.com/blog/2006/05/04/UsermodeAPCsAndManagedCode.aspx">lot of reasons like state corruption among other things</a> this should not be done. Moreover, you are passing managed delegates to native code. So GC can always kick in. So to prove it, I am changing the sample size from 1000 to 100000.</p><br /><p>Firstly, it wouldn’t work and you will be greeted with a nice dialog.</p><br /><p><a href="http://lh4.ggpht.com/-15Xbi2Ct0Hg/UJiAQsJJseI/AAAAAAAABeA/MhNxGx0dOmg/s1600-h/image%25255B7%25255D.png"><img style="background-image: none; border-right-width: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px; padding-top: 0px" title="image" border="0" alt="image" src="http://lh4.ggpht.com/-6vrQN11_V8I/UJiARJpXtGI/AAAAAAAABeI/OIdKDCXsqEg/image_thumb%25255B3%25255D.png?imgmax=800" width="344" height="205"></a></p><br /><p>So run it in debug mode and you will get a nice little MDA called “CallbackOnCollectedDelegate" shall be raised. This simply says that the delegate you passed to native code is GC’d already. </p><br /><p><a href="http://lh5.ggpht.com/-XKd7PqYRRFU/UJiARiXmKpI/AAAAAAAABeQ/IJD3nDmuAK4/s1600-h/image%25255B11%25255D.png"><img style="background-image: none; border-right-width: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px; padding-top: 0px" title="image" border="0" alt="image" src="http://lh3.ggpht.com/-FmREQ-ejXXk/UJiASHQCyTI/AAAAAAAABeU/vu9B1HxccDw/image_thumb%25255B4%25255D.png?imgmax=800" width="344" height="154"></a></p><br /><p>Or even this:</p><br /><p><a href="http://lh4.ggpht.com/-zu5wHmzhKrA/UJiASk7JXcI/AAAAAAAABeg/wSnfqah7VhA/s1600-h/image%25255B15%25255D.png"><img style="background-image: none; border-right-width: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px; padding-top: 0px" title="image" border="0" alt="image" src="http://lh4.ggpht.com/-7fMASb9OyOA/UJiATS5yXII/AAAAAAAABeo/-hoNLcpfNKE/image_thumb%25255B6%25255D.png?imgmax=800" width="350" height="177"></a></p><br /><p>So the experiment which was doomed to fail did fail. Long story short – don’t mess with your threads.</p>  