---           
layout: post
title: Breaking my head with message passing and Scala Actors
date: 2010-02-05 00:53:08 UTC
updated: 2010-02-05 00:53:08 UTC
comments: false
categories: 
---

<p>I recently started working on a personal project on which a friend of mine is helping. After some discussion, we thought Scala might be a good bet to use as the development platform of our choice (and we integrate Spring into Scala). Anyway for that, I got into Scala actors. Actors appear easy code â€“ all you have to do is create an actor (if you use Actor.actor construct, it starts automatically, otherwise you have to invoke start) and from somewhere keep sending messages to the Actor.</p>  <p>So let us first define what message that I want to send using Case Classes. Refer the documentation on case classes.</p>  <pre name="code" class="scala"><br />case class Message(someData : String)<br /></pre><br /><br /><p>Now let us create our component which is an Actor and for each string passed in the constructor, we append the message (Some stupid behavior, but serves the example here)</p><br /><br /><pre name="code" class="scala"><br />class MyActor(toInform: Array[String]) extends scala.actors.Actor{<br />  private val noticeTo = toInform<br />  def act(){<br />    loop{<br />      react{<br />        case Message(r) =>{<br />            for(item<-noticeTo)<br />              println(item+"_"+r)<br />          }<br />      }<br />    }<br />  }<br />}<br /></pre><br /><br /><p>Now with the following code to test the above actor</p><br /><br /><pre name="code" class="scala"><br />val actor = new MyActor(Array("Krishna"))<br />actor ! "Welcome"<br /></pre><br /><br /><p>With all the excitement in the world, you run the test and it just hangs in there, nothing happens :). So you suddenly realize "YOU FORGOT TO START THE ACTOR". Damn! it was the actor.start that is causing the issue. So you cleverly add the actor.start statement. ("you" meaning "me")</p><br /><br /><pre name="code" class="scala"><br />val actor = new MyActor(Array("Krishna"))<br />actor.start //do not forget this :)<br />actor ! "Welcome"<br /></pre><br /><br /><p>You run the test again, to have no success. Then you realize that your actor expects Message(r) where as you are sending a String. So you change that</p><br /><br /><pre name="code" class="scala"><br />val actor = new MyActor(Array("Krishna"))<br />actor.start //do not forget this :)<br />actor ! Message("Welcome")<br />//actor.exit<br /></pre><br /><br /><p>Also notice the commented out explicit kill of the exit call outside the actor. It is not advised to be doing that. Remeber that "!" is a send-and-continue kinda call (asynchronous call). So before the actor is scheduled to work on the message, it might be killed. Instead it is advised that you specify an "Exit" like message within the case on the Actor. Now you run the test and it works :) Hurray!!!!</p><br /><br /><p> Later, smart-ass like you (this time, it is you :)), decide to write a very bad code (ok, you is not really you, for now lets assume the actor code i wrote is simply perfect) like shown below.</p><br /><br /><pre name="code" class="scala"><br />object Launcher extends Application{<br />  val actor = new MyActor(null)<br />  actor start() //do not forget this<br />  actor ! Message("Welcome")<br />  actor ! "E" //this is the exit message.<br />}<br /></pre><br /><br /><p>You repeat the test again :) and this time it does nothing, it appears to be blocked :). Again....damn... so how would we know what the issue is? You spend a your day-off trying to figure out what is wrong with this simple code...then after spending 10 hours trying all the magic tricks (aparently, i know too many magic tricks that never work, hence the time), you realize the actor must be dead (netbeans threads view would show what threads are running and you never see any FJ Threads). So the actor died! So what can kill an actor? - call to exit(), or an exception!!!! There it is .. so let us change the actor code so that it can catch the exception.</p><br /><br /><pre name="code" class="scala"><br />class MyActor(toInform: Array[String]) extends scala.actors.Actor{<br />  private val noticeTo = toInform<br />  def act(){<br />    loop{<br />      react{<br />        case Message(r) =>{<br />            try{<br />            for(item<-noticeTo)<br />              println(item+"_"+r)<br />            }catch{<br />              case e => e.printStackTrace<br />            }<br />          }<br />        case "E" => exit<br />      }<br />    }<br />  }<br />}<br /></pre><br /><br /><p>Run the test again and notice the stacktrace! </p><br /><br /><pre name="code" class="scala"><br />java.lang.NullPointerException<br />        at scala.collection.mutable.ArrayOps$ofRef.length(ArrayOps.scala:68)<br />        at scala.collection.IndexedSeqLike$class.foreach(IndexedSeqLike.scala:86)<br />        at scala.collection.mutable.ArrayOps.foreach(ArrayOps.scala:20)<br />        at tryscala.MyActor$$anonfun$act$1$$anonfun$apply$1.apply(Launcher.scala:13)<br />        at tryscala.MyActor$$anonfun$act$1$$anonfun$apply$1.apply(Launcher.scala:10)<br />        at scala.actors.Reaction$$anonfun$$init$$1.apply(Reaction.scala:33)<br />        at scala.actors.Reaction$$anonfun$$init$$1.apply(Reaction.scala:29)<br />        at scala.actors.ReactorTask.run(ReactorTask.scala:33)<br />        at scala.actors.scheduler.ForkJoinScheduler$$anon$1.compute(ForkJoinScheduler.scala:111)<br />        at scala.concurrent.forkjoin.RecursiveAction.exec(RecursiveAction.java:147)<br />        at scala.concurrent.forkjoin.ForkJoinTask.quietlyExec(ForkJoinTask.java:422)<br />        at scala.concurrent.forkjoin.ForkJoinWorkerThread.mainLoop(ForkJoinWorkerThread.java:340)<br />        at scala.concurrent.forkjoin.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:325)<br />BUILD SUCCESSFUL (total time: 7 seconds)<br /></pre><br /><br /><p>So the fix is to :) pass in an empty array at least, instead of sending in a null ( use Array.empty).</p><br /><br /><p>Clearly, this is not the exact sample that I was running, it was a little bit complicated and myself being totally new to Scala had a hard time trying to figure out that an exception can kill scala Actors!!! I know I am dumb, but with this post, I want to save you from considering yourself dumb after trying very hard for a few hours.</p>  