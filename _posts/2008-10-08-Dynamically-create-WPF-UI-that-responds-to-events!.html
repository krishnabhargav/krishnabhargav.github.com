---           
layout: post
title: Dynamically create WPF UI that responds to events!
date: 2008-10-08 21:15:22 UTC
updated: 2008-10-08 21:15:22 UTC
comments: false
categories: 
---

<p>This is kind of complex, but simple in a totally different sense. As we all know one could create WPF elements on the fly using XamlReader.Load(). Shown below is snippet of code that does exactly this.</p><pre class="code"><font face="Calibri"><span style="color: blue">private string </span>xmlns = <span style="color: #a31515">"http://schemas.microsoft.com/winfx/2006/xaml/presentation"</span>;<br /><span style="color: blue">private string </span>xmlns_x = <span style="color: #a31515">"http://schemas.microsoft.com/winfx/2006/xaml"</span>;<br /><br /> <span style="color: blue">private object </span>GetUIFromXaml()<br /> {<br />           <span style="color: #2b91af">XmlDocument </span>xdoc = GetXamlDoc();<br /><br />           <span style="color: gray">///</span></font><font face="Calibri"><span style="color: green">Now we are done with modifications, so we need an XmlReader. In this case, we use a XmlTextReader<br />           </span><span style="color: gray">/// </span></font><font face="Calibri"><span style="color: green">We build a StringReader on the updated xml.<br />           </span><span style="color: #2b91af">XmlTextReader </span>xmlReader = <span style="color: blue">new </span><span style="color: #2b91af">XmlTextReader</span>(<span style="color: blue">new </span><span style="color: #2b91af">StringReader</span>(xdoc.OuterXml));<br /><br />           <span style="color: gray">///</span></font><font face="Calibri"><span style="color: green">The above code is all the ground work needed to successfully load Xaml at runtime.<br />           </span><span style="color: gray">///</span></font><font face="Calibri"><span style="color: green">The  XamlReader.Load() does the trick here. It compiles the Xaml into BAML and then builds the Object graph.<br />           </span><span style="color: gray">/// </span></font><font face="Calibri"><span style="color: green">At the sametime, both the Visual Tree as well as the Logical Tree is constructed.<br />           </span><span style="color: blue">return </span><span style="color: #2b91af">XamlReader</span>.Load(xmlReader);<br />}<br /><br /> <span style="color: blue">private </span><span style="color: #2b91af">XmlDocument </span>GetXamlDoc()<br /> {<br />      <span style="color: gray">///</span></font><font face="Calibri"><span style="color: green">Xaml is XML. So we load the XAML as an XmlDocument.<br />       </span><span style="color: gray">/// </span></font><font face="Calibri"><span style="color: green">The reason XmlDocument is used instead of XDocument is that we would like to add namespaces<br />           </span><span style="color: gray">/// </span></font><font face="Calibri"><span style="color: green">so that the parsing is performed without issues. <br />           </span><span style="color: #2b91af">XmlDocument </span>xdoc = <span style="color: blue">new </span><span style="color: #2b91af">XmlDocument</span>();<br />           xdoc.LoadXml(txtCode.Text);<br /><br />           <span style="color: gray">///</span></font><font face="Calibri"><span style="color: green">We need to add the presentation framework namespace as well as the XAML namespace.<br />           </span><span style="color: gray">///</span><span style="color: green">This way a </span><span style="color: gray">&lt;Button&gt; </span></font><font face="Calibri"><span style="color: green">like WPF objects would be properly identified.<br />           </span><span style="color: blue">if </span>(<span style="color: blue">string</span>.IsNullOrEmpty(xdoc.DocumentElement.GetAttribute(<span style="color: #a31515">"xmlns"</span>))) xdoc.DocumentElement.SetAttribute(<span style="color: #a31515">"xmlns"</span>, xmlns);<br />           <span style="color: blue">if </span>(<span style="color: blue">string</span>.IsNullOrEmpty(xdoc.DocumentElement.GetAttribute(<span style="color: #a31515">"xmlns:x"</span>))) xdoc.DocumentElement.SetAttribute(<span style="color: #a31515">"xmlns:x"</span>, xmlns_x);<br />           <span style="color: blue">return </span>xdoc;<br /> }</font></pre><br /><p>The GetXamlDoc method simply attaches namespaces to the XAML we wish to add. This way, even a XAML like </p><pre class="code"><font face="Calibri"><span style="color: blue">&lt;</span><span style="color: #a31515">TextBlock </span><span style="color: red">Name</span><span style="color: blue">="txtErrors"  </span><span style="color: red">FontWeight</span><span style="color: blue">="20" </span><span style="color: red">Text</span><span style="color: blue">="Enter Code and Press TAB"/&gt;</span></font></pre><br /><p>would work without issues. The XamlReader would then know where to look for TextBlock.<br><br>Now, the requirement is that we want to load buttons from XAML and attach event handler to button at "runtime". The general requirement is that we should be able to attach handlers to any WPF elements and this requires a lot of ground work which I am not showing here. So, I just simplified the problem to attach dynamic event handlers to only buttons.</p><br /><p><span style="color: green">//Create UI from XAML.<br></span><span style="color: blue">object</span>obj = GetUIFromXaml();<br><span style="color: #2b91af">Button</span>b = obj <span style="color: blue">as</span><span style="color: #2b91af">Button</span>;<br><span style="color: blue">if</span>(b != <span style="color: blue">null</span>)<br>&nbsp;&nbsp;&nbsp; AddHandlerToButton(b);</p>Now, the AddHandlerToButton method looks like shown.<br><pre class="code"><font face="Calibri"><span style="color: blue">private void </span>AddHandlerToButton(<span style="color: #2b91af">Button </span>b)<br />{<br /><span style="color: blue">if </span>(b.Name == <span style="color: #a31515">"empty"</span>)<br />  {<br />                b.AddHandler(<span style="color: #2b91af">Button</span>.ClickEvent, <span style="color: #2b91af">Delegate</span>.CreateDelegate(<span style="color: #2b91af">Button</span>.ClickEvent.HandlerType, <span style="color: blue">typeof</span>(<span style="color: #2b91af">Page1</span>).GetMethod(<span style="color: #a31515">"b_Click"</span>,<span style="color: #2b91af">BindingFlags</span>.Public|<span style="color: #2b91af">BindingFlags</span>.Static), <span style="color: blue">false</span>));<br />            }<br /><br />}<br /><font color="#111111">So, the method shown above adds handler to the click event of the button by creating a delegate at runtime. Note that BindingFlags.Static is very important here. Otherwise, the reflection framework would try to instantiate Page1, which fails in InitializeComponent call. So make the b_Click as static such that no initialization takes place and you would successfully bind the method. Without the method being static, CreateDelegate would throw an ArgumentException saying "Error binding method to  target".</font></font></pre><pre class="code"><font face="Calibri" color="#111111">The use of reflection allows one to make a completely dynamic WPF loader framework which can make use of user plugins, which defines static method handlers for WPF elements. He can then write a configuration based AddHandlerToElement method which loads the user plugin(dll) and attach the methods based on the configuration settings.</font></pre><pre class="code"><font color="#111111"><font face="Calibri">Note that you could also have done a d.Click += new RoutedEventHandler(b_Click); but this is not configurable.<br>Note that the XAML parsed would not allow "Click" or other events to be set within XAML. So you might want to add a separate piece of config which defines the names of the events, their handlers for a given element name. For example,<br></font><strong><font face="Calibri">&lt;Element name="empty" event="Click" method="b_Click" assemblyName="myassembly.dll,.,...."/&gt;<br></font></strong></font><font color="#111111"><font face="Calibri">Hopefully, this would help many who wants to make full use of dynamically created WPF forms.<br><br></font></pre></font><pre class="code"><font face="Calibri"><font color="#111111">&nbsp;</pre></font></font>  